<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编写第一个Qt程序</title>
      <link href="2021/04/17/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAQt%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/04/17/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAQt%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h1><h1 id="hello-word-1"><a href="#hello-word-1" class="headerlink" title="hello word"></a>hello word</h1><p><img src="../image/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAQt%E7%A8%8B%E5%BA%8F/image-20210417180117920.png" alt="image-20210417180117920"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bootz启动linux内核过程</title>
      <link href="2020/04/06/bootz%E5%90%AF%E5%8A%A8linux%E5%86%85%E6%A0%B8%E8%BF%87%E7%A8%8B/"/>
      <url>2020/04/06/bootz%E5%90%AF%E5%8A%A8linux%E5%86%85%E6%A0%B8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在启动 Linux 内核的时候都会用到一个重要的全局变量：images，images 在文件 cmd/bootm.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Legacy and FIT format headers used by do_bootm() and do_bootm_&lt;os&gt;()</span></span><br><span class="line"><span class="comment"> * routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment"> * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment"> * data from second and third component accordingly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">image_header_t</span>*legacy_hdr_os;<span class="comment">/* image header pointer */</span></span><br><span class="line"><span class="keyword">image_header_t</span>legacy_hdr_os_copy;<span class="comment">/* header copy */</span></span><br><span class="line">ulonglegacy_hdr_valid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FIT)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*fit_uname_cfg;<span class="comment">/* configuration node unit name */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*fit_hdr_os;<span class="comment">/* os FIT image header */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*fit_uname_os;<span class="comment">/* os subimage node unit name */</span></span><br><span class="line"><span class="keyword">int</span>fit_noffset_os;<span class="comment">/* os subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*fit_hdr_rd;<span class="comment">/* init ramdisk FIT image header */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*fit_uname_rd;<span class="comment">/* init ramdisk subimage node unit name */</span></span><br><span class="line"><span class="keyword">int</span>fit_noffset_rd;<span class="comment">/* init ramdisk subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*fit_hdr_fdt;<span class="comment">/* FDT blob FIT image header */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*fit_uname_fdt;<span class="comment">/* FDT blob subimage node unit name */</span></span><br><span class="line"><span class="keyword">int</span>fit_noffset_fdt;<span class="comment">/* FDT blob subimage node offset */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*fit_hdr_setup;<span class="comment">/* x86 setup FIT image header */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*fit_uname_setup; <span class="comment">/* x86 setup subimage node name */</span></span><br><span class="line"><span class="keyword">int</span>fit_noffset_setup;<span class="comment">/* x86 setup subimage node offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line"><span class="keyword">image_info_t</span>os;<span class="comment">/* os image info */</span></span><br><span class="line">ulongep;<span class="comment">/* entry point of OS */</span></span><br><span class="line"></span><br><span class="line">ulongrd_start, rd_end;<span class="comment">/* ramdisk start/end */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*ft_addr;<span class="comment">/* flat dev tree address */</span></span><br><span class="line">ulongft_len;<span class="comment">/* length of flat device tree */</span></span><br><span class="line"></span><br><span class="line">ulonginitrd_start;</span><br><span class="line">ulonginitrd_end;</span><br><span class="line">ulongcmdline_start;</span><br><span class="line">ulongcmdline_end;</span><br><span class="line"><span class="keyword">bd_t</span>*kbd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>verify;<span class="comment">/* getenv("verify")[0] != 'n' */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_START(0x00000001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_FINDOS(0x00000002)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_FINDOTHER(0x00000004)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_LOADOS(0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_RAMDISK(0x00000010)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_FDT(0x00000020)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_OS_CMDLINE(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_OS_BD_T(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_OS_PREP(0x00000100)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_OS_FAKE_GO(0x00000200)<span class="comment">/* 'Almost' run the OS */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>BOOTM_STATE_OS_GO(0x00000400)</span></span><br><span class="line"><span class="keyword">int</span>state;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lmb</span><span class="title">lmb</span>;</span><span class="comment">/* for memory mgmt */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">bootm_headers_t</span>;</span><br></pre></td></tr></table></figure><p>在uboot启动分析二中，uboot使用命令使用的是do_XXX函数，所以，启动bootz函数使用的是do_bootz函数，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_bootz</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Consume 'bootz' */</span></span><br><span class="line">argc--; argv++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bootz_start(cmdtp, flag, argc, argv, &amp;images))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We are doing the BOOTM_STATE_LOADOS state ourselves, so must</span></span><br><span class="line"><span class="comment"> * disable interrupts ourselves</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bootm_disable_interrupts();</span><br><span class="line"></span><br><span class="line">images.os.os = IH_OS_LINUX;</span><br><span class="line">ret = do_bootm_states(cmdtp, flag, argc, argv,</span><br><span class="line">      BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">      BOOTM_STATE_OS_GO,</span><br><span class="line">      &amp;images, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bootz-start函数"><a href="#bootz-start函数" class="headerlink" title="bootz_start函数"></a>bootz_start函数</h2>]]></content>
      
      
      <categories>
          
          <category> uboot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull-uboot分析（二）</title>
      <link href="2020/04/06/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/04/06/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="6-s-init-函数详解"><a href="#6-s-init-函数详解" class="headerlink" title="6. s_init 函数详解"></a>6. s_init 函数详解</h2><p>lowlevel_init函数后面会调用 s_init 函数，s_init 函数定义在文件<br>arch/arm/cpu/armv7/mx6/soc.c 中</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anatop_regs</span> *<span class="title">anatop</span> = (<span class="title">struct</span> <span class="title">anatop_regs</span> *)<span class="title">ANATOP_BASE_ADDR</span>;</span> <span class="comment">//0x02000000+0x80000+0x48000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mxc_ccm_reg</span> *<span class="title">ccm</span> = (<span class="title">struct</span> <span class="title">mxc_ccm_reg</span> *)<span class="title">CCM_BASE_ADDR</span>;</span></span><br><span class="line">u32 mask480;</span><br><span class="line">u32 mask528;</span><br><span class="line">u32 reg, periph1, periph2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||</span><br><span class="line">    is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs</span></span><br><span class="line"><span class="comment"> * to make sure PFD is working right, otherwise, PFDs may</span></span><br><span class="line"><span class="comment"> * not output clock after reset, MX6DL and MX6SL have added 396M pfd</span></span><br><span class="line"><span class="comment"> * workaround in ROM code, as bus clock need it</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mask480 = ANATOP_PFD_CLKGATE_MASK(<span class="number">0</span>) |</span><br><span class="line">ANATOP_PFD_CLKGATE_MASK(<span class="number">1</span>) |</span><br><span class="line">ANATOP_PFD_CLKGATE_MASK(<span class="number">2</span>) |</span><br><span class="line">ANATOP_PFD_CLKGATE_MASK(<span class="number">3</span>);</span><br><span class="line">mask528 = ANATOP_PFD_CLKGATE_MASK(<span class="number">1</span>) |</span><br><span class="line">ANATOP_PFD_CLKGATE_MASK(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">reg = readl(&amp;ccm-&gt;cbcmr);</span><br><span class="line">periph2 = ((reg &amp; MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK)</span><br><span class="line">&gt;&gt; MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET);</span><br><span class="line">periph1 = ((reg &amp; MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK)</span><br><span class="line">&gt;&gt; MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Checking if PLL2 PFD0 or PLL2 PFD2 is using for periph clock */</span></span><br><span class="line"><span class="keyword">if</span> ((periph2 != <span class="number">0x2</span>) &amp;&amp; (periph1 != <span class="number">0x2</span>))</span><br><span class="line">mask528 |= ANATOP_PFD_CLKGATE_MASK(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((periph2 != <span class="number">0x1</span>) &amp;&amp; (periph1 != <span class="number">0x1</span>) &amp;&amp;</span><br><span class="line">(periph2 != <span class="number">0x3</span>) &amp;&amp; (periph1 != <span class="number">0x3</span>))</span><br><span class="line">mask528 |= ANATOP_PFD_CLKGATE_MASK(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">writel(mask480, &amp;anatop-&gt;pfd_480_set);</span><br><span class="line">writel(mask528, &amp;anatop-&gt;pfd_528_set);</span><br><span class="line">writel(mask480, &amp;anatop-&gt;pfd_480_clr);</span><br><span class="line">writel(mask528, &amp;anatop-&gt;pfd_528_clr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//第9行，条件为真 直接返回。</p><h2 id="7-main函数详解"><a href="#7-main函数详解" class="headerlink" title="7._main函数详解"></a>7._main函数详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ldrsp, &#x3D;(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line"></span><br><span class="line">bicsp, sp, #7&#x2F;* 8-byte alignment for ABI compliance *&#x2F;</span><br><span class="line"></span><br><span class="line">movr0, sp</span><br><span class="line">blboard_init_f_alloc_reserve</span><br><span class="line">movsp, r0</span><br><span class="line">&#x2F;* set up gd here, outside any C code *&#x2F;</span><br><span class="line">movr9, r0</span><br><span class="line">blboard_init_f_init_reserve   </span><br><span class="line"></span><br><span class="line">movr0, #0</span><br><span class="line">blboard_init_f</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Set up intermediate environment (new sp and gd) and call</span><br><span class="line"> * relocate_code(addr_moni). Trick here is that we&#39;ll return</span><br><span class="line"> * &#39;here&#39; but relocated.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ldrsp, [r9, #GD_START_ADDR_SP]&#x2F;* sp &#x3D; gd-&gt;start_addr_sp *&#x2F;</span><br><span class="line">#if defined(CONFIG_CPU_V7M)&#x2F;* v7M forbids using SP as BIC destination *&#x2F;</span><br><span class="line">movr3, sp</span><br><span class="line">bicr3, r3, #7</span><br><span class="line">movsp, r3</span><br><span class="line">#else</span><br><span class="line">bicsp, sp, #7&#x2F;* 8-byte alignment for ABI compliance *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">ldrr9, [r9, #GD_BD]&#x2F;* r9 &#x3D; gd-&gt;bd *&#x2F;</span><br><span class="line">subr9, r9, #GD_SIZE&#x2F;* new GD is below bd *&#x2F;</span><br><span class="line"></span><br><span class="line">adrlr, here</span><br><span class="line">ldrr0, [r9, #GD_RELOC_OFF]&#x2F;* r0 &#x3D; gd-&gt;reloc_off *&#x2F;</span><br><span class="line">addlr, lr, r0</span><br><span class="line">#if defined(CONFIG_CPU_V7M)</span><br><span class="line">orrlr, #1&#x2F;* As required by Thumb-only *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">ldrr0, [r9, #GD_RELOCADDR]&#x2F;* r0 &#x3D; gd-&gt;relocaddr *&#x2F;</span><br><span class="line">brelocate_code</span><br><span class="line">here:</span><br><span class="line">&#x2F;*</span><br><span class="line"> * now relocate vectors</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">blrelocate_vectors</span><br><span class="line"></span><br><span class="line">&#x2F;* Set up final (full) environment *&#x2F;</span><br><span class="line"></span><br><span class="line">blc_runtime_cpu_setup&#x2F;* we still call old routine here *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)</span><br><span class="line"># ifdef CONFIG_SPL_BUILD</span><br><span class="line">&#x2F;* Use a DRAM stack for the rest of SPL, if requested *&#x2F;</span><br><span class="line">blspl_relocate_stack_gd</span><br><span class="line">cmpr0, #0</span><br><span class="line">movnesp, r0</span><br><span class="line">movner9, r0</span><br><span class="line"># endif</span><br><span class="line">ldrr0, &#x3D;__bss_start&#x2F;* this is auto-relocated! *&#x2F;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_USE_ARCH_MEMSET</span><br><span class="line">ldrr3, &#x3D;__bss_end&#x2F;* this is auto-relocated! *&#x2F;</span><br><span class="line">movr1, #0x00000000&#x2F;* prepare zero to clear BSS *&#x2F;</span><br><span class="line"></span><br><span class="line">subsr2, r3, r0&#x2F;* r2 &#x3D; memset len *&#x2F;</span><br><span class="line">blmemset</span><br><span class="line">#else</span><br><span class="line">ldrr1, &#x3D;__bss_end&#x2F;* this is auto-relocated! *&#x2F;</span><br><span class="line">movr2, #0x00000000&#x2F;* prepare zero to clear BSS *&#x2F;</span><br><span class="line"></span><br><span class="line">clbss_l:cmpr0, r1&#x2F;* while not at end of BSS *&#x2F;</span><br><span class="line">#if defined(CONFIG_CPU_V7M)</span><br><span class="line">ittlo</span><br><span class="line">#endif</span><br><span class="line">strlor2, [r0]&#x2F;* clear 32-bit BSS word *&#x2F;</span><br><span class="line">addlor0, r0, #4&#x2F;* move to next *&#x2F;</span><br><span class="line">bloclbss_l</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD) &#x2F;&#x2F;未定义</span><br><span class="line">bl coloured_LED_init</span><br><span class="line">bl red_led_on</span><br><span class="line">#endif</span><br><span class="line">&#x2F;* call board_init_r(gd_t *id, ulong dest_addr) *&#x2F;</span><br><span class="line">mov     r0, r9                  &#x2F;* gd_t *&#x2F;</span><br><span class="line">ldrr1, [r9, #GD_RELOCADDR]&#x2F;* dest_addr *&#x2F;</span><br><span class="line">&#x2F;* call board_init_r *&#x2F;</span><br><span class="line">#if defined(CONFIG_SYS_THUMB_BUILD)</span><br><span class="line">ldrlr, &#x3D;board_init_r&#x2F;* this is auto-relocated! *&#x2F;</span><br><span class="line">bxlr</span><br><span class="line">#else</span><br><span class="line">ldrpc, &#x3D;board_init_r&#x2F;* this is auto-relocated! *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">&#x2F;* we should not return here. *&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></table></figure><p>设置SP指针0X0091FF00  （片内的地址）</p><p>函数 board_init_f_alloc_reserve 主要是留出早期的 malloc 内存区域和 gd 内存区域，其中<br>CONFIG_SYS_MALLOC_F_LEN=0X400( 在 文 件 include/generated/autoconf.h 中 定 义 ) ，<br>sizeof(struct global_data)=248(GD_SIZE 值)</p><p>完成后地址图<img src="/2020/04/06/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/E:%5C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Csource_posts%5C1585828502121.png" alt="1585828502121"></p><p>执行    bl    board_init_f_init_reserve   函数， 初始化gd指针（0），其中base += roundup(sizeof(struct global_data), 16);  为除16后向上取整数， 最终 gd-&gt;malloc_base=0X0091FB00，这个也就是 early malloc 的起始地址。</p><p><strong>执行 board_init_f 函数</strong></p><p>重新设置环境(sp 和 gd)、获取 gd-&gt;start_addr_sp 的值赋给 sp  ，sp=gd-&gt;start_addr_sp=0X9EF44E90。0X9EF44E90 是 DDR 中的地址</p><p>8字节对齐</p><p><strong>执行    relocate_code函数</strong></p><p><strong>执行    relocate_vectors函数**</strong></p><p>执行    c_runtime_cpu_setup函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(c_runtime_cpu_setup)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * If I-cache is enabled invalidate it</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifndef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">mcrp15, 0, r0, c7, c5, 0@ invalidate icache</span><br><span class="line">mcr     p15, 0, r0, c7, c10, 4@ DSB</span><br><span class="line">mcr     p15, 0, r0, c7, c5, 4@ ISB</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">bxlr</span><br><span class="line"></span><br><span class="line">ENDPROC(c_runtime_cpu_setup)</span><br></pre></td></tr></table></figure><p>清除 BSS 段。</p><p><strong>调用 board_init_r    /* this is auto-relocated! */</strong></p><p>以上加粗四个函数分别解析</p><h2 id="board-init-f-函数解析"><a href="#board-init-f-函数解析" class="headerlink" title="board_init_f 函数解析"></a>board_init_f 函数解析</h2><p>board_init_f 函数主要有两个工作：<br>①、初始化一系列外设，比如串口、定时器，或者打印一些消息等。<br>②、初始化 gd 的各个成员变量，uboot 会将自己重定位到 DRAM 最后面的地址区域，也就<br>是将自己拷贝到 DRAM 最后面的内存区域中。这么做的目的是给 Linux 腾出空间，防止 Linux<br>kernel 覆盖掉 uboot，将 DRAM 前面的区域完整的空出来。在拷贝之前肯定要给 uboot 各部分<br>分配好内存位置和大小，比如 gd 应该存放到哪个位置，malloc 内存池应该存放到哪个位置等<br>等。这些信息都保存在 gd 的成员变量中，因此要对 gd 的这些成员变量做初始化</p><p>完成之后的内存分配如下</p><p><img src="/2020/04/06/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/E:%5C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%5Csource_posts%5C1586089289524.png" alt="1586089289524"></p><h2 id="relocate-code-函数解析"><a href="#relocate-code-函数解析" class="headerlink" title="relocate_code 函数解析"></a>relocate_code 函数解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_code)</span><br><span class="line">ldrr1, &#x3D;__image_copy_start&#x2F;*__image_copy_start&#x3D;0X87800000 *&#x2F;</span><br><span class="line">subsr4, r0, r1&#x2F;* r4 &lt;- relocation offset *&#x2F;</span><br><span class="line">beqrelocate_done&#x2F;* skip relocation *&#x2F;</span><br><span class="line">ldrr2, &#x3D;__image_copy_end&#x2F;* r2 &lt;- SRC &amp;__image_copy_end *&#x2F;</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">ldmiar1!, &#123;r10-r11&#125;&#x2F;* 拷贝r1开始的地址的两个字节到r10 r11    *&#x2F;</span><br><span class="line">stmiar0!, &#123;r10-r11&#125;&#x2F;* 将r10 r11的值放入r0，也就是目标地址    *&#x2F;</span><br><span class="line">cmpr1, r2&#x2F;*比较是否拷贝完   *&#x2F;</span><br><span class="line">blocopy_loop</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 对变量进行重定位，变量的标号地址会保存在rel段中，同时还有0x17。组成一对。</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">ldrr2, &#x3D;__rel_dyn_start&#x2F;* r2 &lt;- SRC &amp;__rel_dyn_start *&#x2F;</span><br><span class="line">ldrr3, &#x3D;__rel_dyn_end&#x2F;* r3 &lt;- SRC &amp;__rel_dyn_end *&#x2F;</span><br><span class="line">fixloop:</span><br><span class="line">ldmiar2!, &#123;r0-r1&#125;&#x2F;* (r0,r1) &lt;- (SRC location,fixup)</span><br><span class="line">    *subsr4, r0, r1&#x2F;**&#x2F;</span><br><span class="line">andr1, r1, #0xff</span><br><span class="line">cmpr1, #23&#x2F;* relative fixup? *&#x2F;</span><br><span class="line">bnefixnext</span><br><span class="line"></span><br><span class="line">&#x2F;* relative fix: increase location by offset  加入偏移值，r4 保存着偏移值*&#x2F;</span><br><span class="line">addr0, r0, r4</span><br><span class="line">ldrr1, [r0]</span><br><span class="line">addr1, r1, r4</span><br><span class="line">strr1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">cmpr2, r3</span><br><span class="line">blofixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line">&#x2F;*---无定义省略*&#x2F;</span><br><span class="line">bxlr</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure><h2 id="relocate-vectors-函数详解"><a href="#relocate-vectors-函数详解" class="headerlink" title="relocate_vectors  函数详解"></a>relocate_vectors  函数详解</h2><p>函数 relocate_vectors 用于重定位向量表，此函数定义在文件 relocate.S 中。下面省略无宏定义代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_vectors)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * If the ARM processor has the security extensions,</span><br><span class="line"> * use VBAR to relocate the exception vectors.</span><br><span class="line"> *&#x2F;</span><br><span class="line">ldrr0, [r9, #GD_RELOCADDR]&#x2F;* r0 &#x3D; gd-&gt;relocaddr *&#x2F;</span><br><span class="line">mcr     p15, 0, r0, c12, c0, 0  &#x2F;* Set VBAR *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">bxlr</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_vectors)</span><br></pre></td></tr></table></figure><p>将 r9（gd指针的值）加上偏移值，然后设置VBAR寄存器。</p><h2 id="board-init-r-函数"><a href="#board-init-r-函数" class="headerlink" title="board_init_r    函数"></a>board_init_r    函数</h2><p>类似于board_init_f函数，初始化一个执行函数数组如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">init_fnc_t init_sequence_r[] &#x3D; &#123;</span><br><span class="line">initr_trace,&#x2F;*初始化和调试跟踪有关的内容*&#x2F;</span><br><span class="line">initr_reloc,&#x2F;*设置 gd-&gt;flags，标记重定位完成*&#x2F;</span><br><span class="line">&#x2F;* TODO: could x86&#x2F;PPC have this also perhaps? *&#x2F;</span><br><span class="line">#ifdef CONFIG_ARM</span><br><span class="line">initr_caches,&#x2F;*函数用于初始化 cache，使能 cache。*&#x2F;</span><br><span class="line">&#x2F;* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.</span><br><span class="line"> * A temporary mapping of IFC high region is since removed,</span><br><span class="line"> * so environmental variables in NOR flash is not availble</span><br><span class="line"> * until board_init() is called below to remap IFC to high</span><br><span class="line"> * region.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">initr_reloc_global_data,&#x2F;*初始化重定位后 gd 的一些成员变量。*&#x2F;</span><br><span class="line">#if defined(CONFIG_SYS_INIT_RAM_LOCK) &amp;&amp; defined(CONFIG_E500)</span><br><span class="line">initr_unlock_ram_in_cache,</span><br><span class="line">#endif</span><br><span class="line">initr_barrier,</span><br><span class="line">initr_malloc,</span><br><span class="line">initr_console_record,</span><br><span class="line">#ifdef CONFIG_SYS_NONCACHED_MEMORY</span><br><span class="line">initr_noncached,</span><br><span class="line">#endif</span><br><span class="line">bootstage_relocate, &#x2F;*启动状态重定位*&#x2F;</span><br><span class="line">#ifdef CONFIG_DM</span><br><span class="line">initr_dm,</span><br><span class="line">#endif</span><br><span class="line">initr_bootstage,</span><br><span class="line">#if defined(CONFIG_ARM) || defined(CONFIG_NDS32)</span><br><span class="line">board_init,&#x2F;* 板级初始化，包括 74XX 芯片，I2C、FEC、USB 和 QSPI 等。</span><br><span class="line">这里执行的是 mx6ull_alientek_emmc.c 文件中的 board_init 函数 *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">&#x2F;*</span><br><span class="line"> * TODO: printing of the clock inforamtion of the board is now</span><br><span class="line"> * implemented as part of bdinfo command. Currently only support for</span><br><span class="line"> * davinci SOC&#39;s is added. Remove this check once all the board</span><br><span class="line"> * implement this.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef CONFIG_CLOCKS</span><br><span class="line">set_cpu_clk_info, &#x2F;* 设置CPU时钟 *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">stdio_init_tables,</span><br><span class="line">initr_serial,</span><br><span class="line">initr_announce,</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#ifdef CONFIG_NEEDS_MANUAL_RELOC</span><br><span class="line">initr_manual_reloc_cmdtable,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_PPC) || defined(CONFIG_M68K)</span><br><span class="line">initr_trap,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_ADDR_MAP</span><br><span class="line">initr_addr_map,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_BOARD_EARLY_INIT_R)</span><br><span class="line">board_early_init_r,</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#ifdef CONFIG_LOGBUFFER</span><br><span class="line">initr_logbuffer,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_POST</span><br><span class="line">initr_post_backlog,</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#ifdef CONFIG_SYS_DELAYED_ICACHE</span><br><span class="line">initr_icache_enable,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_PCI) &amp;&amp; defined(CONFIG_SYS_EARLY_PCI_INIT)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Do early PCI configuration _before_ the flash gets initialised,</span><br><span class="line"> * because PCU ressources are crucial for flash access on some boards.</span><br><span class="line"> *&#x2F;</span><br><span class="line">initr_pci,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_WINBOND_83C553</span><br><span class="line">initr_w83c553f,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_ARCH_EARLY_INIT_R</span><br><span class="line">arch_early_init_r,</span><br><span class="line">#endif</span><br><span class="line">power_init_board,</span><br><span class="line">#ifndef CONFIG_SYS_NO_FLASH</span><br><span class="line">initr_flash,</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86) || \</span><br><span class="line">defined(CONFIG_SPARC)</span><br><span class="line">&#x2F;* initialize higher level parts of CPU like time base and timers *&#x2F;</span><br><span class="line">cpu_init_r,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PPC</span><br><span class="line">initr_spi,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_NAND</span><br><span class="line">initr_nand,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_ONENAND</span><br><span class="line">initr_onenand,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_GENERIC_MMC</span><br><span class="line">initr_mmc,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_HAS_DATAFLASH</span><br><span class="line">initr_dataflash,</span><br><span class="line">#endif</span><br><span class="line">initr_env,</span><br><span class="line">#ifdef CONFIG_SYS_BOOTPARAMS_LEN</span><br><span class="line">initr_malloc_bootparams,</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">initr_secondary_cpu,</span><br><span class="line">#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)</span><br><span class="line">mac_read_from_eeprom,</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#if defined(CONFIG_PCI) &amp;&amp; !defined(CONFIG_SYS_EARLY_PCI_INIT)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Do pci configuration</span><br><span class="line"> *&#x2F;</span><br><span class="line">initr_pci,</span><br><span class="line">#endif</span><br><span class="line">stdio_add_devices,</span><br><span class="line">initr_jumptable,</span><br><span class="line">#ifdef CONFIG_API</span><br><span class="line">initr_api,</span><br><span class="line">#endif</span><br><span class="line">console_init_r,&#x2F;* fully init console as a device *&#x2F;</span><br><span class="line">#ifdef CONFIG_DISPLAY_BOARDINFO_LATE</span><br><span class="line">show_board_info,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_ARCH_MISC_INIT</span><br><span class="line">arch_misc_init,&#x2F;* miscellaneous arch-dependent init *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_MISC_INIT_R</span><br><span class="line">misc_init_r,&#x2F;* miscellaneous platform-dependent init *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">#ifdef CONFIG_CMD_KGDB</span><br><span class="line">initr_kgdb,</span><br><span class="line">#endif</span><br><span class="line">interrupt_init,</span><br><span class="line">#if defined(CONFIG_ARM) || defined(CONFIG_AVR32)</span><br><span class="line">initr_enable_interrupts,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_MICROBLAZE) || defined(CONFIG_AVR32) || defined(CONFIG_M68K)</span><br><span class="line">timer_init,&#x2F;* initialize timer *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_STATUS_LED)</span><br><span class="line">initr_status_led,</span><br><span class="line">#endif</span><br><span class="line">&#x2F;* PPC has a udelay(20) here dating from 2002. Why? *&#x2F;</span><br><span class="line">#ifdef CONFIG_CMD_NET</span><br><span class="line">initr_ethaddr,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_BOARD_LATE_INIT</span><br><span class="line">board_late_init,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FSL_FASTBOOT</span><br><span class="line">initr_fastboot_setup,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CMD_AMBAPP)</span><br><span class="line">ambapp_init_reloc,</span><br><span class="line">#if defined(CONFIG_SYS_AMBAPP_PRINT_ON_STARTUP)</span><br><span class="line">initr_ambapp_print,</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_SCSI</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">initr_scsi,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_DOC</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">initr_doc,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_BITBANGMII</span><br><span class="line">initr_bbmii,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_NET</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">initr_net,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_POST</span><br><span class="line">initr_post,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CMD_PCMCIA) &amp;&amp; !defined(CONFIG_CMD_IDE)</span><br><span class="line">initr_pcmcia,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CMD_IDE)</span><br><span class="line">initr_ide,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_LAST_STAGE_INIT</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Some parts can be only initialized if all others (like</span><br><span class="line"> * Interrupts) are up and running (i.e. the PC-style ISA</span><br><span class="line"> * keyboard).</span><br><span class="line"> *&#x2F;</span><br><span class="line">last_stage_init,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CMD_BEDBUG</span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">initr_bedbug,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)</span><br><span class="line">initr_mem,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PS2KBD</span><br><span class="line">initr_kbd,</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_SPARC)</span><br><span class="line">prom_init,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FSL_FASTBOOT</span><br><span class="line">initr_check_fastboot,</span><br><span class="line">#endif</span><br><span class="line">run_main_loop,  &#x2F;*主循环，处理命令*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="run-main-loop函数"><a href="#run-main-loop函数" class="headerlink" title="run_main_loop函数"></a>run_main_loop函数</h2><p>uboot 启动以后会进入 3 秒倒计时，如果在 3 秒倒计时结束之前按下按下回车键，那么就<br>会进入 uboot 的命令模式，如果倒计时结束以后都没有按下回车键，那么就会自动启动 Linux 内<br>核，这个功能就是由 run_main_loop 函数来完成的</p><p>printf(“\b\b\b%2d “, bootdelay);  退格显示delay值。。。</p><p>倒计时结束后运行cli_loop();</p><p> uboot 的命令行处理函数，我们在 uboot 中输入各种命令，进行各种操作就<br>是有 cli_loop 来处理的，此函数定义在文件 common/cli.c 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">parse_stream_outervoid <span class="title">cli_loop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">parse_file_outer();  <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parse_stream_outer -&gt; run_list(ctx.list_head);  -&gt; run_list_real(pi); -&gt;  run_pipe_real(struct pipe *pi) -&gt; cmd_process(flag, child-&gt;argc, child-&gt;argv, &amp;flag_repeat, NULL);</p><h2 id="uboot使用宏U-BOOT-CMD"><a href="#uboot使用宏U-BOOT-CMD" class="headerlink" title="uboot使用宏U_BOOT_CMD"></a>uboot使用宏U_BOOT_CMD</h2><p>来定义命令，宏 U_BOOT_CMD 定义在文件 include/command.h 中</p><p>最终展示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmd_tbl_t</span> _u_boot_list_2_cmd_2_dhcp __aligned(<span class="number">4</span>) </span><br><span class="line">__attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) </span><br><span class="line">&#123;<span class="string">"dhcp"</span>, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, </span><br><span class="line"> <span class="string">"boot image via network using DHCP/TFTP protocol"</span>, </span><br><span class="line"> <span class="string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span>,</span><br><span class="line"> <span class="literal">NULL</span>&#125;</span><br></pre></td></tr></table></figure><p>也就是创建一个 cmd_tbl_t 类型的变量</p><p>cmd_process 调用find_cmd函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmd_tbl_t *find_cmd(const char *cmd)</span><br><span class="line">&#123;</span><br><span class="line">cmd_tbl_t *start &#x3D; ll_entry_start(cmd_tbl_t, cmd);</span><br><span class="line">const int len &#x3D; ll_entry_count(cmd_tbl_t, cmd);</span><br><span class="line">return find_cmd_tbl(cmd, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用函数 cmd_call 来执行具体的命令</p><p>cmd_call(cmdtp, flag, argc, argv);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_call</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line">debug(<span class="string">"Command failed, result=%d\n"</span>, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此uboot已经完成，下一步分析bootz启动linux内核</p>]]></content>
      
      
      <categories>
          
          <category> uboot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull—uboot分析（一）</title>
      <link href="2020/04/01/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/04/01/imx6ull-uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-编译uboot"><a href="#一-编译uboot" class="headerlink" title="一.编译uboot"></a>一.编译uboot</h1><p>编译配置文件在uboot-imx-rel_imx_4.1.15_2.1.0_ga\configs文件夹</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">ake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr3_arm2_emmc_defconfig  </span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1 -j12</span><br></pre></td></tr></table></figure><p><img src="/images/imx6ull%E2%80%94%E2%80%94uboot%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/1585745101773.png" alt="1585745101773"></p><p>分析u-boot.ld文件</p><p>节选如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . &#x3D; 0x00000000;</span><br><span class="line"> . &#x3D; ALIGN(4);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> . &#x3D; ALIGN(4);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"> . &#x3D; ALIGN(4);</span><br><span class="line"> .data : &#123;</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"> . &#x3D; ALIG</span><br></pre></td></tr></table></figure><p>打卡u-boot.map文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit u-boot.map</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*(.__image_copy_start)</span><br><span class="line"> .__image_copy_start</span><br><span class="line">                0x0000000087800000        0x0 arch&#x2F;arm&#x2F;lib&#x2F;built-in.o</span><br><span class="line">                0x0000000087800000                __image_copy_start</span><br><span class="line"> *(.vectors)</span><br><span class="line"> .vectors       0x0000000087800000      0x300 arch&#x2F;arm&#x2F;lib&#x2F;built-in.o</span><br><span class="line">                0x0000000087800000                _start</span><br><span class="line">                0x0000000087800020                _undefined_instruction</span><br><span class="line">                0x0000000087800024                _software_interrupt</span><br><span class="line">                0x0000000087800028                _prefetch_abort</span><br><span class="line">                0x000000008780002c                _data_abort</span><br><span class="line">                0x0000000087800030                _not_used</span><br><span class="line">                0x0000000087800034                _irq</span><br><span class="line">                0x0000000087800038                _fiq</span><br><span class="line">                0x0000000087800040                IRQ_STACK_START_IN</span><br><span class="line"> arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;start.o(.text*)</span><br><span class="line"> .text          0x0000000087800300       0xb0 arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;start.o</span><br><span class="line">                0x0000000087800300                reset</span><br><span class="line">                0x0000000087800304                save_boot_params_ret</span><br><span class="line">                0x0000000087800340                c_runtime_cpu_setup</span><br><span class="line">                0x0000000087800350                save_boot_params</span><br><span class="line">                0x0000000087800354                cpu_init_cp15</span><br><span class="line">                0x00000000878003a8                cpu_init_crit</span><br></pre></td></tr></table></figure><p>反汇编u-boot文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-objdump -D -m arm u-boot &gt; u-boot.dis</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">u-boot:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">87800000 &lt;__image_copy_start&gt;:</span><br><span class="line">87800000:ea0000be b87800300 &lt;reset&gt;</span><br><span class="line">87800004:e59ff014 ldrpc, [pc, #20]; 87800020 &lt;_undefined_instruction&gt;</span><br><span class="line">87800008:e59ff014 ldrpc, [pc, #20]; 87800024 &lt;_software_interrupt&gt;</span><br><span class="line">8780000c:e59ff014 ldrpc, [pc, #20]; 87800028 &lt;_prefetch_abort&gt;</span><br><span class="line">87800010:e59ff014 ldrpc, [pc, #20]; 8780002c &lt;_data_abort&gt;</span><br><span class="line">87800014:e59ff014 ldrpc, [pc, #20]; 87800030 &lt;_not_used&gt;</span><br><span class="line">87800018:e59ff014 ldrpc, [pc, #20]; 87800034 &lt;_irq&gt;</span><br><span class="line">8780001c:e59ff014 ldrpc, [pc, #20]; 87800038 &lt;_fiq&gt;</span><br></pre></td></tr></table></figure><p>综上所述：u-boot开头定义了中断向量表reset以及&lt;_undefined_instruction&gt;等中断向量。然后</p><p>跳转到uboot-imx-rel_imx_4.1.15_2.1.0_ga\arch\arm\cpu\armv7\start.S文件执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">&#x2F;* Allow the board to save important registers *&#x2F;</span><br><span class="line">bsave_boot_params</span><br><span class="line">save_boot_params_ret:</span><br><span class="line">&#x2F;*</span><br><span class="line"> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line"> * except if in HYP mode already</span><br><span class="line"> *&#x2F;</span><br><span class="line">mrsr0, cpsr</span><br><span class="line">andr1, r0, #0x1f@ mask mode bits</span><br><span class="line">teqr1, #0x1a@ test for HYP mode</span><br><span class="line">bicner0, r0, #0x1f@ clear all mode bits</span><br><span class="line">orrner0, r0, #0x13@ set SVC mode</span><br><span class="line">orrr0, r0, #0xc0@ disable FIQ and IRQ</span><br><span class="line">msrcpsr,r0</span><br></pre></td></tr></table></figure><h1 id="二。U-Boot-启动流程"><a href="#二。U-Boot-启动流程" class="headerlink" title="二。U-Boot 启动流程"></a>二。U-Boot 启动流程</h1><h2 id="1-关闭中断，初始化cpu为SVC32模式"><a href="#1-关闭中断，初始化cpu为SVC32模式" class="headerlink" title="1.关闭中断，初始化cpu为SVC32模式"></a>1.关闭中断，初始化cpu为SVC32模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mrsr0, cpsr</span><br><span class="line">andr1, r0, #0x1f@ mask mode bits</span><br><span class="line">teqr1, #0x1a@ test for HYP mode</span><br><span class="line">bicner0, r0, #0x1f@ clear all mode bits</span><br><span class="line">orrner0, r0, #0x13@ set SVC mode</span><br><span class="line">orrr0, r0, #0xc0@ disable FIQ and IRQ</span><br><span class="line">msrcpsr,r0</span><br></pre></td></tr></table></figure><h2 id="2-设置向量表重定位"><a href="#2-设置向量表重定位" class="headerlink" title="2.设置向量表重定位"></a>2.设置向量表重定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line">&#x2F;* Set V&#x3D;0 in CP15 SCTLR register - for VBAR to point to vector *&#x2F;</span><br><span class="line">mrcp15, 0, r0, c1, c0, 0@ Read CP15 SCTLR Register</span><br><span class="line">bicr0, #CR_V@ V &#x3D; 0</span><br><span class="line">mcrp15, 0, r0, c1, c0, 0@ Write CP15 SCTLR Register</span><br><span class="line"></span><br><span class="line">&#x2F;* Set vector address in CP15 VBAR register *&#x2F;</span><br><span class="line">ldrr0, &#x3D;_start</span><br><span class="line">mcrp15, 0, r0, c12, c0, 0@Set VBAR</span><br></pre></td></tr></table></figure><h2 id="3-跳转到-cpu-init-cp15函数"><a href="#3-跳转到-cpu-init-cp15函数" class="headerlink" title="3.跳转到  cpu_init_cp15函数"></a>3.跳转到  cpu_init_cp15函数</h2><p>关闭 MMU Icha等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Invalidate L1 I&#x2F;D</span><br><span class="line"> *&#x2F;</span><br><span class="line">movr0, #0@ set up for MCR</span><br><span class="line">mcrp15, 0, r0, c8, c7, 0@ invalidate TLBs</span><br><span class="line">mcrp15, 0, r0, c7, c5, 0@ invalidate icache</span><br><span class="line">mcrp15, 0, r0, c7, c5, 6@ invalidate BP array</span><br><span class="line">mcr     p15, 0, r0, c7, c10, 4@ DSB</span><br><span class="line">mcr     p15, 0, r0, c7, c5, 4@ ISB</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * disable MMU stuff and caches</span><br><span class="line"> *&#x2F;</span><br><span class="line">mrcp15, 0, r0, c1, c0, 0</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">movpc, r5@ back to my caller</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></table></figure><h2 id="4-跳转到cpu-init-crit函数"><a href="#4-跳转到cpu-init-crit函数" class="headerlink" title="4.跳转到cpu_init_crit函数"></a>4.跳转到cpu_init_crit函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(cpu_init_crit)</span><br><span class="line"></span><br><span class="line">blowlevel_init@ go setup pll,mux,memory</span><br><span class="line">ENDPROC(cpu_init_crit)</span><br></pre></td></tr></table></figure><h2 id="5-lowlevel-init函数分析"><a href="#5-lowlevel-init函数分析" class="headerlink" title="5.lowlevel_init函数分析"></a>5.lowlevel_init函数分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line"></span><br><span class="line">ldrsp, &#x3D;CONFIG_SYS_INIT_SP_ADDR  # </span><br><span class="line">bicsp, sp, #7 &#x2F;* 8-byte alignment for ABI compliance *&#x2F;</span><br><span class="line"></span><br><span class="line">subsp, sp, #GD_SIZE</span><br><span class="line">bicsp, sp, #7</span><br><span class="line">movr9, sp</span><br><span class="line"></span><br><span class="line"> push&#123;ip, lr&#125;</span><br><span class="line"></span><br><span class="line">bls_init</span><br><span class="line">pop&#123;ip, pc&#125;</span><br><span class="line"></span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></table></figure><p>CONFIG_SYS_INIT_SP_ADDR = 0x00900000 +(0x00020000-256) =0X91FF00</p><p>0090_0000     0091_FFFF      128 KB      OCRAM     128 KB    00900000是片内ROM地址</p><p>bic    sp, sp, #7  8字节对齐</p><p>留出#define GENERATED_BD_INFO_SIZE 80 /* (sizeof(struct bd_info) + 15) &amp; ~15</p><p>空间</p><p>8字节对齐</p><p>调用s_init函数</p>]]></content>
      
      
      <categories>
          
          <category> uboot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SourceInsight添加对汇编语言文件.s和.S的支持</title>
      <link href="2020/03/31/SourceInsight%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6-s%E5%92%8C-S%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>2020/03/31/SourceInsight%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6-s%E5%92%8C-S%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 在使用SourceInsight的过程中，发现使用SourceInsight建立的工程在ADD TREE时，默认设置并没有把该TREE里面所有汇编文件都包含进来，比如.s和.S汇编文件，这样导致搜索时，搜索不到.s和.S汇编文件中的内容，导致查看代码何不方便。</p><a id="more"></a><p>解决方法是在Options-&gt;FileType Options里面，选择x86 Asm Source File，然后在C Source File的File filter里<em>.asm;</em>.inc;的后面加上<em>.s;</em>.S 接着CLOSE就可以了。这样就可以ADD TREE时把这些汇编文件加到工程中了。</p><p><img src="/images/SourceInsight%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6-s%E5%92%8C-S%E7%9A%84%E6%94%AF%E6%8C%81/1585669338525.png" alt="1585669338525"></p><p><img src="/images/SourceInsight%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6-s%E5%92%8C-S%E7%9A%84%E6%94%AF%E6%8C%81/1585669447227.png" alt="1585669447227"></p><p><img src="/images/SourceInsight%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6-s%E5%92%8C-S%E7%9A%84%E6%94%AF%E6%8C%81/1585669547410.png" alt></p><p><strong>注意，如果是已经创建的项目，需要重新创建一下才能将汇编文件添加到工程中。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 软件技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> source insight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode+gdbserver图形化调试</title>
      <link href="2020/03/25/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/"/>
      <url>2020/03/25/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="VSCode-gdbserver-图形化调试"><a href="#VSCode-gdbserver-图形化调试" class="headerlink" title="VSCode+gdbserver  图形化调试"></a>VSCode+gdbserver  图形化调试</h1><h1 id="一-编译GDB源码"><a href="#一-编译GDB源码" class="headerlink" title="一 . 编译GDB源码"></a>一 . 编译GDB源码</h1><h2 id="1-首先到-gdb-官网上获取源码，地址为-http-www-gnu-org-software-gdb-download"><a href="#1-首先到-gdb-官网上获取源码，地址为-http-www-gnu-org-software-gdb-download" class="headerlink" title="1.首先到 gdb 官网上获取源码，地址为 http://www.gnu.org/software/gdb/download/"></a>1.首先到 gdb 官网上获取源码，地址为 <a href="http://www.gnu.org/software/gdb/download/" target="_blank" rel="noopener">http://www.gnu.org/software/gdb/download/</a></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxzf gdb-9.1.tar.gz //解压 gdb 源码</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-编译-gdb"><a href="#2-编译-gdb" class="headerlink" title="2.  编译 gdb"></a>2.  编译 gdb</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.1/  //进入 gdb 源码目录</span><br><span class="line">mkdir build  //在 gdb 源码下新建 build 目录，gdb 编译比较奇葩！不能直接在 gdb 源</span><br><span class="line">//码目录下进行配置和编译，必须新建一个文件夹，然后在此文件夹下配</span><br><span class="line">//置和编译，切记！</span><br><span class="line"><span class="built_in">cd</span> build //进入到刚刚创建的 build 目录下</span><br><span class="line">../configure --target=arm-linux-gnueabihf --</span><br><span class="line">prefix=/home/Nick/linux/IMX6ULL/tool/gdb</span><br><span class="line">//配置 gdb。配置完成以后会在 build 目录下生成 Makefile 文件。</span><br><span class="line">make //编译</span><br><span class="line">make install  //安装</span><br></pre></td></tr></table></figure><p>编译完成以后PC端运行的gdb工具就会安装到gdb/bin目录下.</p><h2 id="3-移植-gdbserver"><a href="#3-移植-gdbserver" class="headerlink" title="3.移植 gdbserver"></a>3.移植 gdbserver</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd gdb-9.1&#x2F;gdb&#x2F;gdbserver  &#x2F;&#x2F;进入到 gdbserver 目录</span><br><span class="line">make CC&#x3D;arm-linux-gnueabihf-gcc  &#x2F;&#x2F;交叉编译 gdbserver</span><br></pre></td></tr></table></figure><p>编译完成以后就会在目录下生成一个名为“gdbserver”的文件,拷贝到开发板中的/usr/bin 目录下。</p><p>完成以后在开发板中输入如下命令查看 gdbserver 版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver --version</span><br></pre></td></tr></table></figure><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585146415558.png" alt="1585146415558"></p><h1 id="二-VSCode-gdbserver-实现图形化界面"><a href="#二-VSCode-gdbserver-实现图形化界面" class="headerlink" title="二 . VSCode+gdbserver 实现图形化界面"></a>二 . VSCode+gdbserver 实现图形化界面</h1><h2 id="1-VSCode-设置"><a href="#1-VSCode-设置" class="headerlink" title="1.VSCode  设置"></a>1.VSCode  设置</h2><h3 id="VScode-安装远程调试插件“Remote-Development”"><a href="#VScode-安装远程调试插件“Remote-Development”" class="headerlink" title="VScode 安装远程调试插件“Remote Development”"></a>VScode 安装远程调试插件“Remote Development”</h3><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585146627435.png" alt="1585146627435"></p><h3 id="点击“调试”-gt-“添加配置”-，然后选择“C-GDB-LLDB-”选项"><a href="#点击“调试”-gt-“添加配置”-，然后选择“C-GDB-LLDB-”选项" class="headerlink" title="点击“调试”-&gt;“添加配置” ，然后选择“C++(GDB/LLDB)”选项"></a>点击“调试”-&gt;“添加配置” ，然后选择“C++(GDB/LLDB)”选项</h3><p>编辑“launch.json”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"gdbtest"</span>,  <span class="comment">//调试的项目名</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/test"</span>, <span class="comment">//需要调试的应用程序可执行文件路径</span></span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,<span class="comment">//需要调试的应用程序源码路径。</span></span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"/home/nick/linux/gcc_tool/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gdb"</span>, <span class="comment">// 此项需要手动添加，用于指定所使用的交叉编译器 gdb 路径。</span></span><br><span class="line">            <span class="string">"miDebuggerServerAddress"</span>: <span class="string">"192.168.31.50:2001"</span><span class="comment">//此项需要手动添加，远程 gdbserver 服务器地址。</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-VSCode-调试方法"><a href="#三-VSCode-调试方法" class="headerlink" title="三 VSCode 调试方法"></a>三 VSCode 调试方法</h2><h3 id="1-启动开发板上的-gdbserver，输入如下命令："><a href="#1-启动开发板上的-gdbserver，输入如下命令：" class="headerlink" title="1.启动开发板上的 gdbserver，输入如下命令："></a>1.启动开发板上的 gdbserver，输入如下命令：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver 192.168.1.253:2001 gdbtest</span><br></pre></td></tr></table></figure><h3 id="2-接下来在点击-VSCode-上的“调试”-gt-“启动调试”按钮"><a href="#2-接下来在点击-VSCode-上的“调试”-gt-“启动调试”按钮" class="headerlink" title="2.接下来在点击 VSCode 上的“调试”-&gt;“启动调试”按钮"></a>2.接下来在点击 VSCode 上的“调试”-&gt;“启动调试”按钮</h3><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585146921972.png" alt="1585146921972"></p><p>由于是通过网络进行调试的，因此启动调试以后会有一个建立连接的过程，可能需要几秒<br>钟，建立成功以后如图</p><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585146947145.png" alt="1585146947145"></p><h3 id="3-调试按钮"><a href="#3-调试按钮" class="headerlink" title="3.调试按钮"></a>3.调试按钮</h3><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585146996290.png" alt="1585146996290"></p><p>可以看出，一共有 6 个控制按钮，这 6 个按钮从左往右功能及快捷键依次如下：<br>①、继续按钮，快捷键为 F5，用于控制程序的运行和暂停，程序运行到断点暂停以后可以<br>按下此按钮继续运行。<br>②、单步跳过按钮，快捷键为 F10。<br>③、单步调试按钮，快捷键为 F11。<br>④、单步跳出按钮，快捷键为 Shift+F11。<br>⑤、重启按钮，快捷键为 Ctrl+Shift+F5。<br>⑥、停止按钮，快捷键为 Shift+F5。</p><h3 id="4-断点添加"><a href="#4-断点添加" class="headerlink" title="4.断点添加"></a>4.断点添加</h3><p>添加断点的方式也很简单，在需要添加断点的行前面，直接点击即可添加或取消断点，断点添加成功以后会在所在行前面显示一个小红点。</p><h3 id="5-监视变量"><a href="#5-监视变量" class="headerlink" title="5.监视变量"></a>5.监视变量</h3><p>有时候我们需要监视一个变量的变化，这个也很简单，鼠标双击选中需要监视的变量名<br>上，然后点击鼠标右键，选择“调试：添加到监视器”</p><p><img src="/images/VSCode-gdbserver%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95/1585147176910.png" alt="1585147176910"></p>]]></content>
      
      
      <categories>
          
          <category> VScode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> vscode调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下的IIC设备驱动分析</title>
      <link href="2020/03/20/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>2020/03/20/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="一-IIC概述"><a href="#一-IIC概述" class="headerlink" title="一.     IIC概述"></a>一.     IIC概述</h1><p>1.IIC总线是PHLIPS公司推出的一种串行总线，是具备多主机系统所需的包括总线裁决和高低速器件同步功能的高性能串行总线。<br>2.IIC总线具有两根双向信号线，一根数据SDA，一根时钟线SCL。<br><img src="/images/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/20180514203538172.jpg" alt></p><a id="more"></a><p>3.I2C总线通过上拉阻接正电源，上拉电阻一般在4.7k~10k之间。当总线空闲时，两根线均为高电平。连到总线上的任一器件输出的低电平，都将使总线的信号变低，即各器件的SDA及SCL都是线“与”关系。</p><p><img src="/images/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/20180515110246982-1584620951866.png" alt></p><p>4.每个接到I2C总线上的器件都有唯一的地址（每个IIC设备都有一只设备ID，主机通过设备ID找到设备，然后开始通信）。主机与其它器件间的数据传输可以是由主机发送数据到其它器件，这时主机即为发送器，总线上收数据的器件则为接收器。</p><h1 id="二-Linux-下IIC-驱动架构"><a href="#二-Linux-下IIC-驱动架构" class="headerlink" title="二.    Linux 下IIC 驱动架构"></a>二.    Linux 下IIC 驱动架构</h1><p>Linux 定义了系统的IIC驱动体系架构，IIC驱动由3部分组成，IIC核心，IIC总线驱动，IIC设备驱动。</p><p><img src="/images/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/20160317213313496.png" alt="img"></p><h2 id="1-架构层次分类"><a href="#1-架构层次分类" class="headerlink" title="1. 架构层次分类"></a>1. 架构层次分类</h2><p>​    第一层： 提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。覆盖图中的硬件实现层</p><p>​    第二层：提供i2c adapter的algorithm，用具体适配器的xxx_xferf()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。覆盖图中的访问抽象层、i2c核心层</p><p>​    第三层：实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的attach_adapter()、detach_adapter()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的挂接。覆盖图中的driver驱动层</p><p>​    第四层：实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。覆盖图中的driver驱动层</p><p>​    第一层和第二层又叫i2c总线驱动(bus)，第三第四属于i2c设备驱动(device driver)。<br>一般情况， 几乎不需要驱动开发人员再添加bus，只需要驱动工程师实现第三层与第四层。</p><h2 id="2-IIC总线驱动"><a href="#2-IIC总线驱动" class="headerlink" title="2.IIC总线驱动"></a>2.IIC总线驱动</h2><p>​    I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动。其中两个重要数据结构i2c_adapter 和 i2c_algorithm。</p><p>​    Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter，i2c_adapter 结构体定义在 include/linux/i2c.h 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* 总线访问算法 */</span></span><br><span class="line"><span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data fields that are valid for all devices*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> timeout;<span class="comment">/* in jiffies */</span></span><br><span class="line"><span class="keyword">int</span> retries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nr;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">48</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>i2c_algorithm 结构体定义在 include/linux/i2c.h 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"><span class="comment">/* 如果适配器算法不能进行i2c级访问，请将master_xfer设置为NULL。 如果适配器算法可以进行SMBus访问，请设置smbus_xfer。 如果设置为NULL，则使用公共i2c消息模拟SMBus协议 */</span></span><br><span class="line"><span class="comment">/* master_xfer应该返回成功处理的消息数量，或错误的负值 */</span></span><br><span class="line"><span class="keyword">int</span> (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br><span class="line">   <span class="keyword">int</span> num);</span><br><span class="line"><span class="keyword">int</span> (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br><span class="line">   <span class="keyword">unsigned</span> short flags, <span class="keyword">char</span> read_write,</span><br><span class="line">   u8 command, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">u32 (*functionality) (struct i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="keyword">int</span> (*reg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="keyword">int</span> (*unreg_slave)(struct i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>i2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构<br>体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter<br>或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter.这两个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_numbered_adapter</span><span class="params">(struct i2c_adapter *adap)</span></span></span><br></pre></td></tr></table></figure><p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter<br>使用静态总线号。</p><h2 id="IIC设备驱动"><a href="#IIC设备驱动" class="headerlink" title="IIC设备驱动"></a>IIC设备驱动</h2><p>​    I2C 设备驱动重点关注两个数据结构：i2c_client 和 i2c_driver</p><p>​    i2c_client 结构体定义在 include/linux/i2c.h 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short flags;<span class="comment">/* div., see below*/</span></span><br><span class="line"><span class="keyword">unsigned</span> short addr;<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit*/</span></span><br><span class="line"><span class="comment">/* addresses are stored in the*/</span></span><br><span class="line"><span class="comment">/* _LOWER_ 7 bits*/</span></span><br><span class="line"><span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span><span class="comment">/* the adapter we sit on*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the device structure*/</span></span><br><span class="line"><span class="keyword">int</span> irq;<span class="comment">/* irq issued by device*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="keyword">i2c_slave_cb_t</span> slave_cb;<span class="comment">/* callback for slave mode*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    i2c_driver 结构体定义在 include/linux/i2c.h 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment"> * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line"><span class="keyword">int</span> (*probe)(struct i2c_client *, <span class="keyword">const</span> struct i2c_device_id *);</span><br><span class="line">    <span class="comment">/*当 I2C 设备和驱动匹配成功以后 probe 函数就会执行，和 platform 驱动一样。*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> (*<span class="built_in">remove</span>)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* driver model interfaces that don't relate to enumeration  */</span></span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct i2c_client *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment"> * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment"> * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment"> * as the alert response's low bit ("event flag").</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*alert)(struct i2c_client *, <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment"> * with the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*command)(struct i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line"><span class="keyword">int</span> (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> short *address_list;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于我们 I2C 设备驱动编写人来说，重点工作就是构建 i2c_driver，构建完成以后需要向<br>Linux 内核注册这个 i2c_driver。i2c_driver 注册函数为 int i2c_register_driver，此函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_register_driver</span><span class="params">(struct <span class="keyword">module</span> *owner,</span></span></span><br><span class="line"><span class="function"><span class="params">struct i2c_driver *driver)</span></span></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><p>​    首先看一张代码层次图，有助于我们的理解</p><p><img src="/images/linux%E4%B8%8B%E7%9A%84IIC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/20160317221220170.png" alt="img"></p><h2 id="编写驱动需要完成的工作"><a href="#编写驱动需要完成的工作" class="headerlink" title="编写驱动需要完成的工作"></a>编写驱动需要完成的工作</h2><p>编写具体的I2C驱动时，工程师需要处理的主要工作如下：</p><p>​    1)、提供I2C适配器的硬件驱动，探测，初始化I2C适配器(如申请I2C的I/O地址和中断号)，驱动CPU控制的I2C适配器从硬件上产生。</p><p>​    2)、提供I2C控制的algorithm, 用具体适配器的xxx_xfer()函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋给i2c_adapter的algo指针。</p><p>​    3)、实现I2C设备驱动中的i2c_driver接口，用具体yyy的yyy_probe()，yyy_remove()，yyy_suspend(),yyy_resume()函数指针和i2c_device_id设备ID表赋给i2c_driver的probe,remove,suspend,resume和id_table指针。</p><p>​    4)、实现I2C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接。</p><p>　面的工作中前两个属于I2C总线驱动，后面两个属于I2C设备驱动</p><h2 id="使用-i2c-transfer-进行-I2C-数据收发的示例代码"><a href="#使用-i2c-transfer-进行-I2C-数据收发的示例代码" class="headerlink" title="使用 i2c_transfer 进行 I2C 数据收发的示例代码"></a>使用 i2c_transfer 进行 I2C 数据收发的示例代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设备结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.....</span><br><span class="line">    <span class="keyword">void</span> *private_data;<span class="comment">/* 私有数据，一般会设置为 i2c_client */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description  : 读取 I2C 设备多个寄存器数据</span></span><br><span class="line"><span class="comment"> * @param – dev  : I2C 设备</span></span><br><span class="line"><span class="comment"> * @param – reg  : 要读取的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param – val  : 读取到的数据</span></span><br><span class="line"><span class="comment"> * @param – len  : 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @return : 操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_read_regs</span><span class="params">(struct xxx_dev *dev, u8 reg, <span class="keyword">void</span> *val,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> = (<span class="title">struct</span> <span class="title">i2c_client</span> *)<span class="title">dev</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器首地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].addr  = client-&gt;addr;<span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = &amp;reg;<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">1</span>;    <span class="comment">/* reg 长度 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span></span><br><span class="line">    msg[<span class="number">1</span>].addr  = client-&gt;addr;<span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">/* 标记为读取数据  */</span></span><br><span class="line">    msg[<span class="number">1</span>].buf  = val;<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">    msg[<span class="number">1</span>].len   = len;<span class="comment">/* 要读取的数据长度 */</span></span><br><span class="line">    </span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description  : 向 I2C 设备多个寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param – dev  : 要写入的设备结构体</span></span><br><span class="line"><span class="comment"> * @param – reg  : 要写入的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param – val  : 要写入的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param – len  : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @return : 操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> s32 <span class="title">xxx_write_regs</span><span class="params">(struct xxx_dev *dev, u8 reg, u8 *buf, u8 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 b[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> = (<span class="title">struct</span> <span class="title">i2c_client</span> *)<span class="title">dev</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">0</span>] = reg;<span class="comment">/* 寄存器首地址*/</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);<span class="comment">/* 将要发送的数据拷贝到数组 b 里面  */</span></span><br><span class="line">    </span><br><span class="line">    msg.addr  = client-&gt;addr;<span class="comment">/* I2C 器件地址 */</span></span><br><span class="line">    msg.flags = <span class="number">0</span>; <span class="comment">/* 标记为写数据 */</span></span><br><span class="line">    </span><br><span class="line">    msg.buf = b;<span class="comment">/* 要发送的数据缓冲区 */</span></span><br><span class="line">    msg.len = len + <span class="number">1</span>;<span class="comment">/* 要发送的数据长度 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>————————————————<br>参考链接：<br>原文链接：<a href="https://blog.csdn.net/zqixiao_09/article/details/50916916" target="_blank" rel="noopener">https://blog.csdn.net/zqixiao_09/article/details/50916916</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux驱动学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 - Linux </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="2019/12/01/about/"/>
      <url>2019/12/01/about/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>A Coder, live in ShenZheng, China.</p></blockquote><p>姓名：Nick_cai<br>现居：深圳<br>GitHub: <a href="https://github.com/Jnickcai" target="_blank" rel="noopener">Jnickcai</a><br>QQ: <a href="http://wpa.qq.com/msgrd?v=3&uin=755721338&site=qq&menu=yes" target="_blank" rel="noopener">755721338</a></p><a id="more"></a><img src="/images/about/me.jpg" width="300" height="200">]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
